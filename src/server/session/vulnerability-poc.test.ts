import { describe, it, expect } from 'vitest';
import { RequestCookies } from '@edge-runtime/cookies';
import { StatelessSessionStore } from './stateless-session-store.js';
import { encrypt } from '../cookies.js';


const getStore = () => new StatelessSessionStore({ secret: 'a-super-secret-key-that-is-long-enough' });

const expiredPayload = { user: 'test' };


// Utility to wait for a specified time.
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

describe('Unhandled Rejection Vulnerability', () => {
  it('should cause an unhandled rejection when an expired session cookie is replayed as a connection token', async () => {
    const store = getStore();
        // 1. Craft an expired JWE cookie manually (expired 1 hour ago)
    const expirationTime = Math.floor(Date.now() / 1000) - 3600;
    const expiredCookieValue = await encrypt(expiredPayload, 'a-super-secret-key-that-is-long-enough', expirationTime);

    // 2. Simulate the attack: place the expired cookie where session & connection-token cookies are expected.
    const attackReqCookies = new RequestCookies(new Headers());
    attackReqCookies.set('appSession', expiredCookieValue);
    attackReqCookies.set('__FC_0', expiredCookieValue);

    // 3. Assert that calling store.get() now throws an error (unhandled rejection path).
    await expect(store.get(attackReqCookies)).rejects.toThrow('"exp" claim timestamp check failed');
  });
});
